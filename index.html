<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dialogue Visualization</title>
  <style>
    .node {
      cursor: pointer;
    }
    .node circle {
      fill: #999;
      stroke: steelblue;
      stroke-width: 3px;
    }
    .node text {
      font: 12px sans-serif;
      fill: #000;
      pointer-events: none;
    }
    .link {
      fill: none;
      stroke: #555;
      stroke-opacity: 0.4;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>
  <div id="tree"></div>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script>
    // Fetch the JSON file
    fetch('dialogues.json')
      .then(response => response.json())
      .then(dialoguesData => {
        const width = 960;
        const height = 600;

        const svg = d3.select("#tree")
          .append("svg")
          .attr("width", width)
          .attr("height", height)
          .append("g")
          .attr("transform", "translate(0,40)");

        const root = d3.hierarchy(dialoguesData[0], d => d.responses);
        const treeLayout = d3.tree().size([width, height - 160]);

        treeLayout(root);

        let i = 0, duration = 750;

        const update = (source) => {
          const treeData = treeLayout(root);
          const nodes = treeData.descendants().reverse();
          const links = treeData.descendants().slice(1);

          nodes.forEach(d => d.y = d.depth * 100);

          const node = svg.selectAll('g.node')
            .data(nodes, d => d.id || (d.id = ++i));

          const nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr('transform', d => `translate(${source.x0},${source.y0})`)
            .on('click', click);

          nodeEnter.append('circle')
            .attr('class', 'node')
            .attr('r', 1e-6)
            .style('fill', d => d._children ? 'lightsteelblue' : '#fff');

          nodeEnter.append('text')
            .attr('dy', '.35em')
            .attr('x', d => d.children || d._children ? -13 : 13)
            .attr('text-anchor', d => d.children || d._children ? 'end' : 'start')
            .text(d => d.data.text);

          const nodeUpdate = nodeEnter.merge(node);

          nodeUpdate.transition()
            .duration(duration)
            .attr('transform', d => `translate(${d.x},${d.y})`);

          nodeUpdate.select('circle.node')
            .attr('r', 10)
            .style('fill', d => d._children ? 'lightsteelblue' : '#fff')
            .attr('cursor', 'pointer');

          const nodeExit = node.exit().transition()
            .duration(duration)
            .attr('transform', d => `translate(${source.x},${source.y})`)
            .remove();

          nodeExit.select('circle')
            .attr('r', 1e-6);

          nodeExit.select('text')
            .style('fill-opacity', 1e-6);

          const link = svg.selectAll('path.link')
            .data(links, d => d.id);

          const linkEnter = link.enter().insert('path', 'g')
            .attr('class', 'link')
            .attr('d', d => {
              const o = {x: source.x0, y: source.y0};
              return diagonal(o, o);
            });

          const linkUpdate = linkEnter.merge(link);

          linkUpdate.transition()
            .duration(duration)
            .attr('d', d => diagonal(d, d.parent));

          link.exit().transition()
            .duration(duration)
            .attr('d', d => {
              const o = {x: source.x, y: source.y};
              return diagonal(o, o);
            })
            .remove();

          nodes.forEach(d => {
            d.x0 = d.x;
            d.y0 = d.y;
          });

          function diagonal(s, d) {
            return `M ${s.x} ${s.y}
                    C ${(s.x + d.x) / 2} ${s.y},
                      ${(s.x + d.x) / 2} ${d.y},
                      ${d.x} ${d.y}`;
          }

          function click(event, d) {
            if (d.children) {
              d._children = d.children;
              d.children = null;
            } else {
              d.children = d._children;
              d._children = null;
            }
            update(d);
          }
        };

        root.x0 = width / 2;
        root.y0 = 0;

        root.children.forEach(collapse);

        update(root);

        function collapse(d) {
          if (d.children) {
            d._children = d.children;
            d._children.forEach(collapse);
            d.children = null;
          }
        }
      });
  </script>
</body>
</html>
