<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dialogue Visualization</title>
  <style>
    .node {
      cursor: pointer;
    }
    .node rect {
      fill: #999;
      stroke: steelblue;
      stroke-width: 1.5px;
    }
    .node text {
      font: 12px sans-serif;
      fill: #000;
      pointer-events: none;
    }
    .link {
      fill: none;
      stroke: #555;
      stroke-opacity: 0.4;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>
  <a href="GPT-4-turbo.html">link text</a>
  <div id="tree"></div>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script>
    fetch('dialogues.json')
      .then(response => response.json())
      .then(dialoguesData => {
        const width = 960;
        const height = 800;

        const svg = d3.select("#tree")
          .append("svg")
          .attr("width", width)
          .attr("height", height)
          .append("g")
          .attr("transform", "translate(40,40)");

        const treeLayout = d3.tree().size([width - 160, height - 160]);

        const root = d3.hierarchy(dialoguesData[0], d => d.responses);
        root.x0 = (width - 160) / 2;
        root.y0 = 0;

        let i = 0;
        const duration = 750;
        const padding = 10;

        const update = (source) => {
          const treeData = treeLayout(root);
          const nodes = treeData.descendants();
          const links = treeData.links();

          nodes.forEach(d => { d.y = d.depth * 100 });

          const node = svg.selectAll('g.node')
            .data(nodes, d => d.id || (d.id = ++i));

          const nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr('transform', d => `translate(${source.x0},${source.y0})`)
            .on('click', click);

          nodeEnter.append('rect')
            .attr('class', 'node-rect')
            .attr('width', 0)
            .attr('height', 0)
            .attr('x', 0)
            .attr('y', 0)
            .style('fill', d => d._children ? 'lightsteelblue' : '#fff');

          nodeEnter.append('text')
            .attr('dy', '.35em')
            .attr('x', 0)
            .attr('text-anchor', 'middle')
            .text(d => d.data.text)
            .each(wrap);

          const nodeUpdate = nodeEnter.merge(node);

          nodeUpdate.transition()
            .duration(duration)
            .attr('transform', d => `translate(${d.x},${d.y})`);

          nodeUpdate.select('rect')
            .attr('width', d => d.bbox.width + padding * 2)
            .attr('height', d => d.bbox.height + padding * 2)
            .attr('x', d => -(d.bbox.width / 2 + padding))
            .attr('y', d => -(d.bbox.height / 2 + padding))
            .style('fill', d => d._children ? 'lightsteelblue' : '#fff')
            .attr('cursor', 'pointer');

          const nodeExit = node.exit().transition()
            .duration(duration)
            .attr('transform', d => `translate(${source.x},${source.y})`)
            .remove();

          nodeExit.select('rect')
            .attr('width', 0)
            .attr('height', 0);

          nodeExit.select('text')
            .style('fill-opacity', 1e-6);

          const link = svg.selectAll('path.link')
            .data(links, d => d.target.id);

          const linkEnter = link.enter().insert('path', 'g')
            .attr('class', 'link')
            .attr('d', d => {
              const o = {x: source.x0, y: source.y0};
              return diagonal(o, o);
            });

          const linkUpdate = linkEnter.merge(link);

          linkUpdate.transition()
            .duration(duration)
            .attr('d', d => diagonal(d.source, d.target));

          link.exit().transition()
            .duration(duration)
            .attr('d', d => {
              const o = {x: source.x, y: source.y};
              return diagonal(o, o);
            })
            .remove();

          nodes.forEach(d => {
            d.x0 = d.x;
            d.y0 = d.y;
          });

          function diagonal(s, d) {
            return `M ${s.x} ${s.y}
                    C ${(s.x + d.x) / 2} ${s.y},
                      ${(s.x + d.x) / 2} ${d.y},
                      ${d.x} ${d.y}`;
          }

          function click(event, d) {
            if (d.children) {
              d._children = d.children;
              d.children = null;
            } else {
              d.children = d._children;
              d._children = null;
            }
            update(d);
          }
        };

        function wrap(d) {
          const self = d3.select(this);
          const text = self.text();
          const words = text.split(/\s+/).reverse();
          let word,
              line = [],
              lineNumber = 0,
              lineHeight = 1.1, // ems
              y = self.attr("y"),
              dy = parseFloat(self.attr("dy")),
              tspan = self.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
          while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > 100) { // limit line width
              line.pop();
              tspan.text(line.join(" "));
              line = [word];
              tspan = self.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
            }
          }
          // Calculate the bounding box after wrapping
          const bbox = self.node().getBBox();
          d.bbox = bbox;
        }

        function collapse(d) {
          if (d.children) {
            d._children = d.children;
            d._children.forEach(collapse);
            d.children = null;
          }
        }

        root.children.forEach(collapse);
        update(root);
      })
      .catch(error => console.error(error));
  </script>
</body>
</html>
